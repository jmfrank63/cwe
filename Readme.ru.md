# Проект Mixed-Deployment-Demo

## Деплоймент с примером кода инфраструктуры

### Обзор

Этот проект-витрина демонстрирует использование terraform / opentofu и kubernetes для
развертывания масштабируемого веб-приложения. Проект состоит из бэкэнд базы данных, фронтэнд балансировщика нагрузки
и двух различных веб-приложений, одно написано на Rust, другое на Java.
Оба веб-приложения не показывают реально полезных функций, а скорее основные
характеристики. Функции были реализованы только один раз, что привело к тому, что
реализованная функция одного приложения отсутствует в другом.

Приложения представляют собой контейнеры, масштабируемые от двух до десяти в виде kubernetes pods.
Они масштабируются вверх и вниз в течение примерно 2 минут. Вся внешняя коммуникация
шифруется SSL, а также коммуникация с базой данных. Одно приложение выполняет завершение SSL,
в то время как другое использует балансировщик нагрузки для завершения SSL-соединения. Конфигурация
в основном выполняется через файлы .env. Есть много грубых моментов, так как развертывания обычно не
на самом деле созданы для легкого развертывания "запиши один раз, развертывай везде", хотя инфраструктура как
код предполагает обратное.

### Предварительные требования

Для запуска проекта рекомендуется использовать ubuntu на базе intel, идеально версии 22.04.

Необходимые установки:

- git
- docker и docker-compose
- minikube
- terraform

Для доступа к данным о погоде вам потребуется доступ в интернет. Чтобы увидеть функции безопасности,
имейте готовый wildcard-сертификат. Если у вас его нет, создайте собственный ЦС
и подпишитесь на него, добавив корневой сертификат в ваш хранилище доверенных сертификатов. Сохраните
сертификат и ключ безопасно как root и дайте ему группу ssl-cert. Добавьте себя в
группу, чтобы иметь возможность запускать проект на уровне исходного кода.

Инструкции по этому вопросу выходят за рамки этого демонстрационного материала. Самый простой способ - использовать
действительный wildcard-сертификат.

Не обязательно, но настоятельно рекомендуется:

- JDK 17
- Rust
- act
- клиент postgres
- curl
- hey

### Запуск проекта

#### Секреты

Сначала предоставьте необходимые данные для файлов `.env`. Используйте `env.example` в качестве шаблонов.
Вы также можете установить переменные среды через `export` или как `TF_<varname>`

Вы можете проверить проект на нескольких уровнях. Базовый - уровень исходного кода.

#### Уровень исходного кода

Подготовьте базу данных postgres в `pgdb`. Установите базу данных нативно или просто
используйте

```bash
docker run -d --name pgdb -e POSTGRES_USER=<...> -e POSTGRES_PASSWORD=<...> postgres:latest
```

Убедитесь, что добавили `127.0.0.1` pgdb в ваш файл `/etc/hosts`, или используйте любой другой способ
для разрешения имени в `localhost`.

Чтобы запустить приложение Rust, просто введите `cargo run --bin server` из корня
репозитория. Теперь вы должны иметь доступ к веб-сайту через `https://localhost:8443`
и к базе данных через `psql -h localhost -U postgres -d postgres`, или эквивалентные имена
которые вы могли указать в файлах .env.

Приложение Rust создает базу данных и выполняет миграции для создания некоторых таблиц.
Оно отображает только простой статический макет веб-сайта. Чтобы запустить конвейер локально для Rust, используйте

```bash
act push
```

из корня репозитория. Конвейер просто компилируется и не выполняет тесты.

Запускайте Rust первым, так как Java-приложение не создает базу данных и завершится неудачно, если запущено первым. В противном случае, войдите в postgres и создайте базу данных postgres.

Чтобы запустить Java-приложение, перейдите в java-server и выполните `./mvnw spring-boot:run`. Вы также можете
выполнить `./mvnw clean install`, чтобы выполнить один тест. Согласно функции, реализованной только один раз,
для Java-приложения отсутствует конвейер.
Вы можете получить доступ к Java-приложению по адресу `http://localhost:8080`, чтобы отобразить список пользователей или
используйте

```bash
curl -X GET http://localhost:8080/api/users
```

Чтобы добавить пользователей, используйте

```bash
curl -X POST http://localhost:8080/api/users -H "Content-Type: application/json" -d '{"name": "John Doe", "email": "john.doe@example.com"}'
```

Для удобства здесь включены `-X GET` и `-X POST`, хотя они необязательны.
Для изменения или удаления пользователей войдите в базу данных.

Вы также можете получить доступ к данным о погоде от норвежской службы погоды. Чтобы получить доступ к данным:

```bash
http://localhost:8080/weather?location=Moscow&utcHour=11
```

Интересный факт:

Вы также можете искать исторические названия. API вернет данные для Stalingrad, Konstantinopel and Koenigsberg, геолокации которых принадлежат соответственно Volgograd, Istambul и Kaliningrad.

#### Уровень Docker

Опять же, сначала подготовьте ваши сертификаты. Поскольку используются реальные сертификаты, они должны принадлежать root и быть членами группы ssl-cert. Локально вы можете добавить себя в эту группу, но для `docker` вы не знаете идентификатор пользователя. Таким образом, используется скрипт entrypoint, чтобы взять сертификат и скопировать его в другой каталог, где права доступа адаптируются для доступа к локальному пользователю docker. Возможно, потребуется изменить права доступа к сертификатам, поэтому копирование необходимо для избежания
изменения группы, также изменяющего права доступа на хосте.

Чтобы запустить приложение в целом, используйте

```bash
docker-compose build
docker-compose up -d
```

Это запустит четыре контейнера: один для базы данных, один для каждого приложения и один для балансировщика нагрузки.
Поскольку все находится в одной сети, нет изоляции сети, поэтому вы можете получить доступ к каждому серверу напрямую
или через балансировщик нагрузки.

Это немного сложно. Хотя это можно сделать настраиваемым, объем работы был бы огромным и не стоил бы затраченного времени. Поэтому вам придется отредактировать haproxy.cfg, чтобы увидеть работу маршрутизации на основе CNI:

Замените предоставленные доменные имена `web.common-work-education.co.uk` и `weather.common-work-education.co.uk` на ваши собственные имена. Добавьте оба из них в `/etc/hosts`, чтобы разрешить их в `localhost`.

Теперь вы должны иметь доступ к приложению о погоде через поддомен weather и web через его поддомен. Локальное отображение часто сталкивается с проблемами кэширования в браузерах на основе chromium, поэтому рекомендуется использовать окно в режиме инкогнито для доступа.

Если вы посмотрите на конфигурацию, вы увидите, как сложно было добиться того, чтобы haproxy маршрутизировал как приложения уровня 4, так и уровня 7, обработав уровень 4 сначала и при обращении к домену уровня 7 направив обратно на localhost на другой порт, где соединение SSL завершается, а затем передается незашифрованным на сервер приложения.

#### Уровень Terraform

Проект можно автоматически развернуть в minikube. Из корня репозитория перейдите в deployment\terraform и выполните:

```bash
minitube tunnel
```

затем

```bash
terraform init
terraform apply -auto-approve
```

Добавьте `10.96.1.254` в ваш файл `/etc/hosts`, чтобы разрешить поддомены weather и web вместо localhost. После
завершения развертывания вы должны иметь доступ к приложению по указанным поддоменам.

Для проверки масштабирования используйте kubectl

```bash
watch -n 1 kubectl get pods
```

динамически покажет вам все в данный момент развернутые поды.

```bash
watch -n 1 kubectl get hpa
```

Если вы удовлетворены обновлениями каждые 30 секунд, вы можете использовать `-w` или `--watch` вместо этого. Поскольку kubernetes поддерживает только одну
сетевую карту на под, снова нет изоляции сети. Это можно уменьшить, добавив сетевые политики, однако в
на реальном производственном окружении используются фактические подсети, и несколько сетевых карт назначаются для экземпляров.
Вы можете удалить комментарии из файла terraform сетевой политики, но это может нарушить обнаружение ресурсов через автоскалер.
Мне удалось открыть порт `10250`, но риск поломки чего-либо путем блокировки нужного трафика высок. Поэтому
сетевые политики были отключены.

#### Устранение неполадок

Если что-то сломается, есть две вероятные причины: сертификаты и значения переменных среды.
Проверьте конфигурационные карты, проверьте журналы или войдите в pod, если что-то сломается, чтобы устранить неполадки. minikube очень удобен для устранения неполадок благодаря чувствительным и интуитивным командам.

#### Известные ошибки

Учетные данные не работают для статистики в minikube. Вместо этого просто нажмите enter, так как имя пользователя и пароль пустые.
CNI не надежно работает в браузерах на основе Chromium, вместо этого используйте режим инкогнито, чтобы избежать проблем с кэшированием.

#### Ограничения

Не было реализовано масштабирование или избыточность для базы данных и балансировщика нагрузки. На самом деле их нужно удвоить как минимум.
Сетевая изоляция или безопасность не реализованы. Приложения не имеют реально полезной функциональности.
